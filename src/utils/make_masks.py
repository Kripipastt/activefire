""" Generates new masks from the combination of masks generated by literature algorithms
The new masks are generated from the union, intersection and voting of the original masks
If a mask does not exist for a given algorithm, a "don't care" value is generated as a mask
"""


import pandas as pd
import numpy as np
import rasterio
from glob import glob
from functools import reduce
from tqdm import tqdm
import cv2
import os
import sys


MASKS_DIR = '../../dataset/masks/patches'

MASKS_ALGORITHMS = ['Schroeder', 'Murphy', 'GOLI_v2']

OUTPUT_DIR = '../../dataset/masks/'

OUTPUT_INTERSECTION = os.path.join(OUTPUT_DIR, 'intersection')
OUTPUT_VOTING = os.path.join(OUTPUT_DIR, 'voting')

NUM_VOTINGS = 2

IMAGE_SIZE = (256, 256)

def load_masks_in_dataframe():

    masks = glob(os.path.join(MASKS_DIR, '*.tif'))

    print('Masks found: {}'.format(len(masks)))

    df = pd.DataFrame(masks ,columns=['masks_path'])
    df['original_name'] = df.masks_path.apply(os.path.basename)
    df['image_name'] = df.original_name.apply(remove_algorithms_name)

    print('Spliting masks...')
    total = 0
    dataframes = []

    # separa as imagens com base no nome dos algoritmos geradores m치scaras
    for i, algorithm in enumerate(MASKS_ALGORITHMS):
        dataframes.append( df[ df['original_name'].str.contains(algorithm) ] )
    
        num_images = len(dataframes[i].index)
        total += num_images
        print('{} - Images: {}'.format(algorithm, num_images))

    return dataframes

def remove_algorithms_name(mask_name):
    """Remove o nome dos algoritmos do nome da m치scara"""

    for algorithm in MASKS_ALGORITHMS:
        mask_name = mask_name.replace('_{}'.format(algorithm), '')

    return mask_name


def make_intersection_masks(dataframes):

    if not os.path.exists(OUTPUT_INTERSECTION):
        print('Creating output dir: {}'.format(OUTPUT_INTERSECTION))
        os.makedirs(OUTPUT_INTERSECTION)

    df_joinend = reduce(lambda x, y: pd.merge(x, y, on = 'image_name'), dataframes)
    print('Generating Intersection masks')
    print('Images to process: {}'.format( len(df_joinend.index) ))
    # recupera as colunas do dataframe que cotem os caminhos para as m치scaras
    masks_columns = [col for col in df_joinend.columns if col.startswith('masks_path')]

    for index, row in tqdm(df_joinend.iterrows()):
        # mascara "dont care" toda Verdadeira
        final_mask = (np.ones(IMAGE_SIZE) == 1)
        
        for mask_column in masks_columns:
            mask, profile = get_mask_arr(row[mask_column])
            # intersecao das m치scaras
            final_mask = np.logical_and(final_mask, mask)

        
        has_fire = final_mask.sum() > 0
        if has_fire:
            write_mask(os.path.join(OUTPUT_INTERSECTION, row['image_name']), final_mask, profile)
    
    print('Intersection masks created')


def make_voting_masks(dataframes):
    if not os.path.exists(OUTPUT_VOTING):
        print('Creating output dir: {}'.format(OUTPUT_VOTING))
        os.makedirs(OUTPUT_VOTING)

    df_joinend = reduce(lambda x, y: pd.merge(x, y, on = 'image_name', how='outer'), dataframes)
    print('Generating Voting masks')
    print('Images to process: {}'.format( len(df_joinend.index) ))

    # get the columns with the masks path
    masks_columns = [col for col in df_joinend.columns if col.startswith('masks_path')]

    for index, row in tqdm(df_joinend.iterrows()):
        # mascara "dont care" toda Falsa
        final_mask = np.zeros(IMAGE_SIZE)

        for mask_column in masks_columns:

            if type(row[mask_column]) != str:
                mask = (np.zeros(IMAGE_SIZE) == 1)
            else:
                mask, profile = get_mask_arr(row[mask_column])

            final_mask += mask

        final_mask = (final_mask >= NUM_VOTINGS)

        has_fire = final_mask.sum() > 0
        if has_fire:
            write_mask(os.path.join(OUTPUT_VOTING, row['image_name']), final_mask, profile)
        

    print('Voting masks created!')


def get_mask_arr(path):
    with rasterio.open(path) as src:
        img = src.read().transpose((1, 2, 0))
        seg = np.array(img, dtype=int)

        return seg[:, :, 0], src.profile


def write_mask(mask_path, mask, profile={}):
    profile.update({'dtype': rasterio.uint8,'count': 1})

    with rasterio.open(mask_path, 'w', **profile) as dst:
        dst.write_band(1, mask.astype(rasterio.uint8))




if __name__ == '__main__':
    dataframes = load_masks_in_dataframe()
    make_intersection_masks(dataframes)
    make_voting_masks(dataframes)
